<?php

namespace App\Services\Payroll;

use App\Models\HR\AttendanceSummary;
use App\Models\HR\Employee;
use App\Models\Payroll\Payroll;
use App\Models\Payroll\PayrollEntry;
use App\Models\Payroll\PayrollItem;
use App\Services\Payroll\WorkingDayComputationService;
use Exception;
use Illuminate\Support\Facades\DB;

/**
 * Description of PayrollItemProcessingService
 *
 * @author ervinne
 */
class PayrollItemProcessingService {

    /** @var WorkingDayComputationService */
//    protected $workingDayComputationService;
    protected $attendanceSummaryProcessorService;

    /** @var PayrollItemComputationSourceProcessingService */
    protected $payrollItemComputationSourceProcessingService;

    public function __construct(PayrollItemComputationSourceProcessingService $payrollItemComputationSourceProcessingService, AttendanceSummaryProcessorService $attendanceSummaryProcessorService) {
        $this->payrollItemComputationSourceProcessingService = $payrollItemComputationSourceProcessingService;
//        $this->workingDayComputationService                  = $workingDayComputationService;
        $this->attendanceSummaryProcessorService             = $attendanceSummaryProcessorService;
    }

    public function processPayrollItems(Employee $employee, Payroll $payroll) {
        try {
            DB::beginTransaction();

            $taxComputerService = new TaxComputerService();

            //  clear payroll entries of the employee that's generated by payroll processing            
            PayrollEntry::where("employee_code", $employee->code)
                    ->where("payroll_generated", 1)
                    ->delete();

            $attendanceSummary                     = $this->attendanceSummaryProcessorService->generateAttendanceSummary($payroll, $employee);
            $attendanceSummary->employee_code      = $employee->code;
            $attendanceSummary->payroll_pay_period = $payroll->pay_period;


            //  adjustments and manually entered payroll entries can also be used
            //  as dependency
            $dependencies  = PayrollEntry::where("employee_code", $employee->code)->get();
            $dependencyMap = [];
            foreach ($dependencies AS $dependency) {
                $dependencyMap[$dependency->code] = $dependency;
            }


            //  use remove duplicates as workaround for duplicating payroll item
            //  when joining with employee payroll item computation
            $payrollItems = $this->removeDuplicates(PayrollItem::
                            ForProcessing($employee->code, $employee->policy->code)
                            ->get()
            );

            $rates = $this->getRates($payrollItems, $attendanceSummary);

            if ($rates) {
                $attendanceSummary->basic_rate  = $rates["basic"];
                $attendanceSummary->daily_rate  = $rates["daily"];
                $attendanceSummary->cutoff_rate = $rates["cutoff"];

                $attendanceSummary->save();
            } else {
                throw new Exception("Salary of employee {$employee->code} not found");
            }

            $generatedPayrollEntries = $this->processPayrollItemsRecursively($employee, $payroll, $attendanceSummary, $payrollItems, $dependencyMap, []);

            //  generate tax
            $payrollEntry                     = new PayrollEntry();
            $payrollEntry->employee_code      = $employee->code;
            $payrollEntry->payroll_item_code  = "STD_D_WHT";
            $payrollEntry->date_applied       = date("Y-m-d");
            $payrollEntry->payroll_pay_period = $payroll->pay_period;
            $payrollEntry->payroll_generated  = true;
            $payrollEntry->qty                = 1;
            $payrollEntry->amount             = $taxComputerService->getEstimatedEmployeeTaxDue($employee, $payroll);

            $payrollEntry->save();

            DB::commit();

            return $generatedPayrollEntries;
        } catch (Exception $ex) {
            DB::rollBack();
            throw $ex;
        }
    }

    private function removeDuplicates($payrollItems) {
        $processed         = [];
        $cleanPayrollItems = [];

        foreach ($payrollItems AS $payrollItem) {
            if (!in_array($payrollItem->code, $processed)) {
                array_push($cleanPayrollItems, $payrollItem);
                array_push($processed, $payrollItem->code);
            }
        }

        return $cleanPayrollItems;
    }

    private function getRates($payrollItems, AttendanceSummary $attendanceSummary) {
        foreach ($payrollItems AS $payrollItem) {
            if ($payrollItem->payslip_display_string == "Salary") {
                $rates = [
                    "basic"  => 0,
                    "cutoff" => 0,
                    "daily"  => 0,
                ];

                switch ($payrollItem->computation_basis) {
                    case "MON":
                        $rates["basic"]  = $payrollItem->amount;
                        $rates["cutoff"] = $payrollItem->amount / 2;
                        $rates["daily"]  = $payrollItem->amount / $attendanceSummary->month_days;
                        break;
                    case "DAY":
                        $rates["basic"]  = $payrollItem->amount;
                        $rates["cutoff"] = $payrollItem->amount * $attendanceSummary * present;
                        $rates["daily"]  = $payrollItem->amount;
                        break;
                }

                return $rates;
            }
        }
    }

    private function processPayrollItemsRecursively(Employee $employee, Payroll $payroll, AttendanceSummary $attendanceSummary, $payrollItemStack, $dependencyMap, $generatedPayrollEntries) {

        if (count($payrollItemStack) <= 0) {
            //  stack is now empty, our job here is done, stop recursion
            return $generatedPayrollEntries;
        }

        //  pop the payroll item from the stack
        $payrollItem = array_shift($payrollItemStack);

        //  Witholding Tax will be computed later
        if ($payrollItem->code == "STD_D_WHT") {
            return $this->processPayrollItemsRecursively($employee, $payroll, $attendanceSummary, $payrollItemStack, $dependencyMap, $generatedPayrollEntries);
        }

        $payrollEntry                     = new PayrollEntry();
        $payrollEntry->employee_code      = $employee->code;
        $payrollEntry->payroll_item_code  = $payrollItem->code;
        $payrollEntry->date_applied       = date("Y-m-d");
        $payrollEntry->payroll_pay_period = $payroll->pay_period;
        $payrollEntry->payroll_generated  = true;

        //  get payroll entry qty
        $qty = $this->getPayrollItemQty($payrollItem, $payroll, $attendanceSummary);

        $payrollEntry->qty = $qty;

        if ($qty > 0) {
            if ($payrollItem->computation_source == null && $payrollItem->amount == null) {
                //  amount, or at least a computation source is required to compute 
                //  the payroll entry amount. Stop the process
                throw new Exception("Payroll entry {$payrollItem->description} of {$employee->first_name} {$employee->last_name} ({$employee->code}) does not have an amount or computation source currently set up. Please check your policy and/or employee settings first before you may process payroll.");
            }

            //  if the payroll item has a designated amount from the employee,
            //  use that amount for the payroll entry
            if ($payrollItem->amount > 0) {
                $payrollEntry->amount = $payrollItem->amount * $payrollItem->multiplier / $payrollItem->divider;
            } else if ($payrollItem->amount <= 0) {
                $payrollEntry->amount = 0;
            }

            //  if this payroll item is dependent on another payroll item, lookup
            //  the dependency and get its amount converted to the computation basis
            //  of the dependent payroll item using payrollItemComputationSourceProcessingService
            if ($payrollItem->computation_source != null) {
                //  before each dependency resolution, validate
                $this->validateDependency($payrollItem, $payrollItemStack, $dependencyMap);

                $dependency           = $dependencyMap[$payrollItem->computation_source];
                $payrollEntry->amount = $this->payrollItemComputationSourceProcessingService->getComputedAmount($payrollItem, $dependency, $dependency->payrollEntry, $attendanceSummary);
            }

            //  for reference in the next iteration
            $payrollItem->payrollEntry = $payrollEntry;
            array_push($generatedPayrollEntries, $payrollEntry);

            //  in case any other payroll item needs this payroll item as dependency,
            //  add it to the map
            $dependencyMap[$payrollItem->code] = $payrollItem;

            $payrollEntry->save();
        } else {
//            echo json_encode($payrollItem);
//            echo "Skipped {$payrollItem->description}";
        }

        return $this->processPayrollItemsRecursively($employee, $payroll, $attendanceSummary, $payrollItemStack, $dependencyMap, $generatedPayrollEntries);
    }

    private function getPayrollItemQty(PayrollItem $payrollItem, Payroll $payroll, AttendanceSummary $attendanceSummary) {

        //  monthly processables (SSS, Philhealth, etc.)
        if ($payrollItem->monthly_processable) {
            return $payroll->include_monthly_processable ? 1 : 0;
        }

        //  working day computation based payroll items
        switch ($payrollItem->code) {
            case "STD_D_A": return $attendanceSummary->absent;
            case "STD_D_HDA": return $attendanceSummary->halfday_absent;
            case "STD_D_BTL": return $attendanceSummary->breaktime_late;
            case "STD_D_LU": return $attendanceSummary->late;
            case "STD_E_TCO": return 0; // TODO
            case "STD_E_GP": return 0; // TODO
        }

        //  Overtimes
        switch ($payrollItem->code) {
            case "STD_E_OT": return $attendanceSummary->overtime;
            case "STD_E_RDOT": return $attendanceSummary->rest_day_overtime;
            case "STD_E_RDRHOT": return $attendanceSummary->rest_day_holiday_overtime;
            case "STD_E_RDSHOT": return $attendanceSummary->rest_day_special_holiday_overtime;
            case "STD_E_RHOT": return $attendanceSummary->holiday_overtime;
            case "STD_E_SHOT": return $attendanceSummary->special_holiday_overtime;
        }

        //  per day based payroll items
//        if ($payrollItem->code == "STD_E_GP") {
//            $gracePeriods = 0;
//            foreach ($attendanceSummary["workingDays"] AS $workingDay) {
//                if ($workingDay["working_day"]) {   //  if there is work for this day
//                }
//            }
//        }
        //  income based payroll items
        switch ($payrollItem->computation_basis) {
            //  per cutoff = half of the employee's salary
            case "MON": return 0.5;
            //  qty = how many days is the empoyee present
            case "DAY": return $attendanceSummary->present;

            case "HR": return ($attendanceSummary->present / 8) - (($attendanceSummary->late + $attendanceSummary->breaktime_late) / 60);

            case "MIN": return ($attendanceSummary->present / (8 * 60)) - (($attendanceSummary->late + $attendanceSummary->breaktime_late));

            case "EA": return 1;
        }

        return 0;
    }

    private function validateDependency(PayrollItem $payrollItem, $payrollItemStack, $dependencyMap) {
        if (!array_key_exists($payrollItem->computation_source, $dependencyMap)) {
            //  check if there are no dependency candidates, if there are none,
            //  stop the process as the dependency cannot be resolved
            $stillHasCandidateDependency = false;

            foreach ($payrollItemStack AS $remainingPayrollItem) {
                if ($remainingPayrollItem->computation_source == null && $remainingPayrollItem->amount) {
                    $stillHasCandidateDependency = true;
                    break;
                }
            }

            if ($stillHasCandidateDependency) {
                throw new Exception("Some of the payroll items' dependency(ies) cannot be resolved. Please check your policy setup and make sure all dependent payroll items have their dependencies set up.");
            }
        }
    }

}
