<?php

namespace App\Services\Payroll;

use App\Models\HR\Employee;
use App\Models\Payroll\Payroll;
use App\Models\Payroll\PayrollEntry;
use App\Models\Payroll\PayrollItem;
use App\Services\Payroll\WorkingDayComputationService;
use Exception;
use Illuminate\Support\Facades\DB;

/**
 * Description of PayrollItemProcessingService
 *
 * @author ervinne
 */
class PayrollItemProcessingService {

    /** @var WorkingDayComputationService */
    protected $workingDayComputationService;

    /** @var PayrollItemComputationSourceProcessingService */
    protected $payrollItemComputationSourceProcessingService;

    public function __construct(PayrollItemComputationSourceProcessingService $payrollItemComputationSourceProcessingService, WorkingDayComputationService $workingDayComputationService) {
        $this->payrollItemComputationSourceProcessingService = $payrollItemComputationSourceProcessingService;
        $this->workingDayComputationService                  = $workingDayComputationService;
    }

    public function processPayrollItems(Employee $employee, Payroll $payroll) {
        try {
            DB::beginTransaction();

            //  clear payroll entries of the employee that's generated by payroll processing            
            PayrollEntry::where("employee_code", $employee->code)
                    ->where("payroll_generated", 1)
                    ->delete();

            $workingDayComputation = $this->workingDayComputationService->getWorkingDays($payroll, $employee);

            //  adjustments and manually entered payroll entries can also be used
            //  as dependency
            $dependencies  = PayrollEntry::where("employee_code", $employee->code)->get();
            $dependencyMap = [];
            foreach ($dependencies AS $dependency) {
                $dependencyMap[$dependency->code] = $dependency;
            }

            //  use remove duplicates as workaround for duplicating payroll item
            //  when joining with employee payroll item computation
            $payrollItems = $this->removeDuplicates(PayrollItem::
                            ForProcessing($employee->code, $employee->policy->code)
                            ->get()
            );

            $generatedPayrollEntries = $this->processPayrollItemsRecursively($employee, $payroll, $workingDayComputation, $payrollItems, $dependencyMap, []);

            DB::commit();

            return $generatedPayrollEntries;
        } catch (Exception $ex) {
            DB::rollBack();
            throw $ex;
        }
    }

    private function removeDuplicates($payrollItems) {
        $processed         = [];
        $cleanPayrollItems = [];

        foreach ($payrollItems AS $payrollItem) {
            if (!in_array($payrollItem->code, $processed)) {
                array_push($cleanPayrollItems, $payrollItem);
                array_push($processed, $payrollItem->code);
            }
        }

        return $cleanPayrollItems;
    }

    private function processPayrollItemsRecursively(Employee $employee, Payroll $payroll, $workingDayComputation, $payrollItemStack, $dependencyMap, $generatedPayrollEntries) {

        if (count($payrollItemStack) <= 0) {
            //  stack is now empty, our job here is done, stop recursion
            return $generatedPayrollEntries;
        }

        //  pop the payroll item from the stack
        $payrollItem = array_shift($payrollItemStack);

        $payrollEntry                     = new PayrollEntry();
        $payrollEntry->employee_code      = $employee->code;
        $payrollEntry->payroll_item_code  = $payrollItem->code;
        $payrollEntry->date_applied       = date("Y-m-d");
        $payrollEntry->payroll_pay_period = $payroll->pay_period;
        $payrollEntry->payroll_generated  = true;

        //  get payroll entry qty
        $qty = $this->getPayrollItemQty($payrollItem, $payroll, $workingDayComputation);

        $payrollEntry->qty = $qty;

        if ($qty > 0) {
            if ($payrollItem->computation_source == null && $payrollItem->amount == null) {
                //  amount, or at least a computation source is required to compute 
                //  the payroll entry amount. Stop the process
                throw new Exception("Payroll entry {$payrollItem->description} of {$employee->first_name} {$employee->last_name} ({$employee->code}) does not have an amount or computation source currently set up. Please check your policy and/or employee settings first before you may process payroll.");
            }

            //  if the payroll item has a designated amount from the employee,
            //  use that amount for the payroll entry
            if ($payrollItem->amount > 0) {
                $payrollEntry->amount = $payrollItem->amount * $payrollItem->multiplier / $payrollItem->divider;
            } else if ($payrollItem->amount <= 0) {
                $payrollEntry->amount = 0;
            }

            //  if this payroll item is dependent on another payroll item, lookup
            //  the dependency and get its amount converted to the computation basis
            //  of the dependent payroll item using payrollItemComputationSourceProcessingService
            if ($payrollItem->computation_source != null) {
                //  before each dependency resolution, validate
                $this->validateDependency($payrollItem, $payrollItemStack, $dependencyMap);

                $dependency           = $dependencyMap[$payrollItem->computation_source];
                $payrollEntry->amount = $this->payrollItemComputationSourceProcessingService->getComputedAmount($payrollItem, $dependency, $dependency->payrollEntry, $workingDayComputation);
            }

            //  for reference in the next iteration
            $payrollItem->payrollEntry = $payrollEntry;
            array_push($generatedPayrollEntries, $payrollEntry);

            //  in case any other payroll item needs this payroll item as dependency,
            //  add it to the map
            $dependencyMap[$payrollItem->code] = $payrollItem;

            $payrollEntry->save();
        } else {
//            echo json_encode($payrollItem);
//            echo "Skipped {$payrollItem->description}";
        }

        return $this->processPayrollItemsRecursively($employee, $payroll, $workingDayComputation, $payrollItemStack, $dependencyMap, $generatedPayrollEntries);
    }

    private function getPayrollItemQty(PayrollItem $payrollItem, Payroll $payroll, $workingDayComputation) {

        //  monthly processables (SSS, Philhealth, etc.)
        if ($payrollItem->monthly_processable) {
            return $payroll->include_monthly_processable ? 1 : 0;
        }

        //  working day computation based payroll items
        switch ($payrollItem->code) {
            case "STD_D_A": return $workingDayComputation["absences"];
            case "STD_D_HDA": return $workingDayComputation["halfDayAbsences"];
            case "STD_D_BTL": return $workingDayComputation["breaktimeLates"];
            case "STD_D_LU": return $workingDayComputation["lates"];
            case "STD_E_TCO": return $workingDayComputation["tardinessConvertedToOvertime"];
            case "STD_E_GP": return $workingDayComputation["gracePeriod"];
        }

        //  per day based payroll items
        if ($payrollItem->code == "STD_E_GP") {
            $gracePeriods = 0;
            foreach ($workingDayComputation["workingDays"] AS $workingDay) {
                if ($workingDay["working_day"]) {   //  if there is work for this day
                }
            }
        }

        //  income based payroll items
        switch ($payrollItem->computation_basis) {
            //  per cutoff = half of the employee's salary
            case "MON": return 0.5;
            //  qty = how many days is the empoyee present
            case "DAY": return $workingDayComputation["workingCutoffDayCount"] - $workingDayComputation["absences"];

            case "HR": return $workingDayComputation["minutesWorked"] / 60;

            case "MIN": return $workingDayComputation["minutesWorked"];

            case "EA": return 1;
        }

        return 0;
    }

    private function validateDependency(PayrollItem $payrollItem, $payrollItemStack, $dependencyMap) {
        if (!array_key_exists($payrollItem->computation_source, $dependencyMap)) {
            //  check if there are no dependency candidates, if there are none,
            //  stop the process as the dependency cannot be resolved
            $stillHasCandidateDependency = false;

            foreach ($payrollItemStack AS $remainingPayrollItem) {
                if ($remainingPayrollItem->computation_source == null && $remainingPayrollItem->amount) {
                    $stillHasCandidateDependency = true;
                    break;
                }
            }

            if ($stillHasCandidateDependency) {
                throw new Exception("Some of the payroll items' dependency(ies) cannot be resolved. Please check your policy setup and make sure all dependent payroll items have their dependencies set up.");
            }
        }
    }

}
